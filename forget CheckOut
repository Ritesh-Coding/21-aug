import concurrent.futures
import pandas as pd

# Define the functions for each operation
def add_one(number):
    return number + 1

def subtract_one(added_value):
    return added_value - 1

def multiply_one(subtracted_value):
    return subtracted_value * 1

# Function to handle the sequence of operations for a single number
def process_number(number):
    added_value = add_one(number)
    subtracted_value = subtract_one(added_value)
    result = multiply_one(subtracted_value)
    return result

def parallel_processing(numbers_df):
    # Create a ProcessPoolExecutor to manage worker processes
    with concurrent.futures.ProcessPoolExecutor() as executor:
        # Use submit to run each number's sequence asynchronously
        futures = [executor.submit(process_number, num) for num in numbers_df['numbers']]

        # Collect the results maintaining order
        numbers_df['results'] = [future.result() for future in concurrent.futures.as_completed(futures)]

    return numbers_df

if __name__ == "__main__":
    # Create a pandas DataFrame with a column of numbers
    numbers_df = pd.DataFrame({
        'numbers': [i for i in range(1, 11)]  # Sample list of numbers
    })

    # Process the numbers in parallel using pandas DataFrame
    results_df = parallel_processing(numbers_df)

    print("Final Results DataFrame:")
    print(results_df)
