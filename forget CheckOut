import multiprocessing

# Define the functions for each operation
def add_one(number):
    return number + 1

def subtract_one(added_value):
    return added_value - 1

def multiply_one(subtracted_value):
    return subtracted_value * 1

# Function to handle the sequence of operations for a single number
def process_number(number):
    added_value = add_one(number)
    subtracted_value = subtract_one(added_value)
    result = multiply_one(subtracted_value)
    return result

def parallel_processing(numbers):
    # Create a pool of processes
    with multiprocessing.Pool() as pool:
        # Use apply_async to run each number's sequence asynchronously
        results = [pool.apply_async(process_number, args=(num,)) for num in numbers]

        # Collect the results maintaining order
        output = [result.get() for result in results]

    return output

if __name__ == "__main__":
    # Sample list of numbers
    numbers = [i for i in range(1, 11)]

    # Process the numbers in parallel
    results = parallel_processing(numbers)

    print("Final Results:", results)
